<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Hair Shader</title>
		<style>
			body { 
				margin: 0;
				overflow: hidden;
			}
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<canvas id="myCanvas"></canvas>
		<script src="../Common/three.js"></script>
		
		<script type="x-shader/x-vertex" id="vertexShader">
			varying vec3 vecPos;
			varying vec3 vecNormal;
			
			void main(){
				vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
				vecPos = modelViewPosition.xyz;
				vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;
				gl_Position = projectionMatrix * modelViewPosition;
			}
		</script>
		
		<script type="x-shader/x-fragment" id="fragmentShader">
			precision highp float;
			
			varying vec3 vecPos;
			varying vec3 vecNormal;
			
			uniform float lightIntensity;
		
			struct PointLight{
				vec3 color;
				vec3 position;
				float distance;
			};
			
			uniform PointLight pointLights[NUM_POINT_LIGHTS];
		
			void main(){
				vec3 diffuse = vec3(0.3, 0.3, 0.0);
				
				vec4 addedLights = vec4(0.0, 0.0, 0.0, 1.0);
				
				for(int i = 0; i < NUM_POINT_LIGHTS; i++){
					vec3 lightDir = normalize(vecPos - pointLights[i].position);
					addedLights.rgb += clamp(dot(-lightDir, vecNormal), 0.0, 1.0) * pointLights[i].color * lightIntensity;
				}
			
				gl_FragColor = vec4(diffuse, 1.0) * addedLights;
			}
		</script>
		
		<script>
			/*float4 bezier(float4 p0, float4 p1, float4 p2, float t) {
				float oneMinusT = 1.0 - t;
				return
					oneMinusT * oneMinusT * p0 +
					2.0f * oneMinusT * t * p1 +
					t * t * p2;
			}*/
			
			function bezier(p0, p1, p2, t){
				var temp0 = p0.clone();
				var temp1 = p1.clone();
				var temp2 = p2.clone();
				var oneMinusT = 1.0 - t;
				
				temp0.multiplyScalar(oneMinusT * oneMinusT);
				temp1.multiplyScalar(2.0 * oneMinusT * t);
				temp2.multiplyScalar(t * t);
				//return (oneMinusT * oneMinusT * p0) + (2.0 * oneMinusT * t * p1) + (t * t * p2);
				return temp0.add(temp1).add(temp2);
			}
			
			var detailLevel = 20;
		
			var renderer;
			var scene;
			var camera;
			var myCanvas = document.getElementById('myCanvas');
			
			//RENDERER
			renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
			renderer.setClearColor(0xffffff);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			
			//CAMERA
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
			camera.position.set(0, 0, 100);
			camera.lookAt(new THREE.Vector3(0, 0, 0));
			
			//SCENE
			scene = new THREE.Scene();
			
			//LIGHTS
			var light = new THREE.AmbientLight(0xffffff, 0.5);
			scene.add(light);
			
			var light = new THREE.PointLight(0xffffff, 1.0);
			light.position.set(0.0, 0.0, 0.1);
			scene.add(light);
			
			//create a blue LineBasicMaterial
			//var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
			
			var material = new THREE.ShaderMaterial({
				uniforms: THREE.UniformsUtils.merge([
					THREE.UniformsLib['lights'],
					{
						lightIntensity: {type: 'f', value: 5.0}
						//textureSampler: {type: 't', value: null}
					}
				]),
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent,
				//transparent: true,
				lights: true
			});
			
			material.needsUpdate = true;
			
			var detailDelta = 1.0 / detailLevel;
			
			for(var j = 0; j < 300; j++){							
				var geometry = new THREE.Geometry();
				
				var p0 = new THREE.Vector3(Math.sin(j), Math.cos(j), Math.sin(j)).multiplyScalar(25);
				var p1 = new THREE.Vector3(Math.cos(j), Math.sin(j), Math.cos(j)).multiplyScalar(25);
				var p2 = new THREE.Vector3(Math.cos(j), Math.cos(j), Math.sin(j)).multiplyScalar(25);
				
				for(var i = 0.0; i <= 1.0; i += detailDelta){
					geometry.vertices.push(bezier(p0, p1, p2, i));
				}
				
				var line = new THREE.Line( geometry, material );
				scene.add( line );
			}

			var delta = 0.0;
			
			function animate() {
				delta += 0.01;
			
				camera.position.set(Math.sin(delta) * 100, 0, Math.cos(delta) * 100);
				camera.lookAt(new THREE.Vector3(0, 0, 0));
			
				requestAnimationFrame( animate );
				
				renderer.render( scene, camera );
			}
			animate();
		</script>
	</body>
</html>	