<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Hair Shader</title>
		<style>
			body { 
				margin: 0;
				overflow: hidden;
			}
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<canvas id="myCanvas"></canvas>
		<script src="../Common/three.js"></script>
		
		<script type="x-shader/x-vertex" id="vertexShader">
			varying vec3 vecPos;
			varying vec3 vecNormal;
			
			void main(){
				vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
				vecPos = modelViewPosition.xyz;
				vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;
				gl_Position = projectionMatrix * modelViewPosition;
			}
		</script>
		
		<script type="x-shader/x-fragment" id="fragmentShader">
			precision highp float;
			
			varying vec3 vecPos;
			varying vec3 vecNormal;
			
			/*uniform float lightIntensity;
		
			struct PointLight{
				vec3 color;
				vec3 position;
				float distance;
			};
			
			uniform PointLight pointLights[NUM_POINT_LIGHTS];*/
		
			void main(){
				vec3 diffuse = vec3(0.3, 0.3, 0.0);
				
				/*vec4 addedLights = vec4(0.0, 0.0, 0.0, 1.0);
				
				for(int i = 0; i < NUM_POINT_LIGHTS; i++){
					vec3 lightDir = normalize(vecPos - pointLights[i].position);
					addedLights.rgb += clamp(dot(-lightDir, vecNormal), 0.0, 1.0) * pointLights[i].color * lightIntensity;
				}*/
			
				gl_FragColor = vec4(diffuse /* + addedLights.xyz*/, 1.0);// * addedLights;
			}
		</script>
		
		<script>
			/*float4 bezier(float4 p0, float4 p1, float4 p2, float t) {
				float oneMinusT = 1.0 - t;
				return
					oneMinusT * oneMinusT * p0 +
					2.0f * oneMinusT * t * p1 +
					t * t * p2;
			}*/
			
			function bezier(p0, p1, p2, t){
				var temp0 = p0.clone();
				var temp1 = p1.clone();
				var temp2 = p2.clone();
				var oneMinusT = 1.0 - t;
				
				temp0.multiplyScalar(oneMinusT * oneMinusT);
				temp1.multiplyScalar(2.0 * oneMinusT * t);
				temp2.multiplyScalar(t * t);
				//return (oneMinusT * oneMinusT * p0) + (2.0 * oneMinusT * t * p1) + (t * t * p2);
				return temp0.add(temp1).add(temp2);
			}
			
			function getStepSample(rootPos, rootNormal, gravity, length, stiffness, delta){
				//float4 subP0 = normalize(nA - (float4(0, v * t0, 0, 0) * _Gravity * t0)) * (v * t0);
				var deltaLength = length * delta;
				var deltaLengthVec = new THREE.Vector3(0, deltaLength, 0);
				var rootTemp = rootNormal.clone();
				var gravityTemp = gravity.clone();
				rootTemp.add(gravityTemp.multiply(deltaLengthVec).multiplyScalar(delta).multiplyScalar(1 - stiffness));
				return rootTemp.multiplyScalar(deltaLength).add(rootPos);
			}
			
			var detailLevel = 20;
		
			var time;
			var renderer;
			var scene;
			var camera;
			var myCanvas = document.getElementById('myCanvas');
			
			//RENDERER
			renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
			renderer.setClearColor(0xffffff);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			
			//CAMERA
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
			camera.position.set(0, 0, 100);
			camera.lookAt(new THREE.Vector3(0, 0, 0));
			
			//SCENE
			scene = new THREE.Scene();
			
			//LIGHTS
			var light = new THREE.AmbientLight(0xffffff, 0.5);
			scene.add(light);
			
			var light = new THREE.PointLight(0xffffff, 1.0);
			light.position.set(100.0, 25.0, 100.0);
			scene.add(light);
			
			//create a blue LineBasicMaterial
			//var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
			
			var material = new THREE.ShaderMaterial({
				uniforms: THREE.UniformsUtils.merge([
					THREE.UniformsLib['lights'],
					{
						lightIntensity: {type: 'f', value: 5.0}
						//textureSampler: {type: 't', value: null}
					}
				]),
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent,
				//transparent: true,
				lights: true
			});
			
			material.needsUpdate = true;
			
			var detailDelta = 1.0 / (detailLevel - 1);
			
			var hairStrandCount = 16;
			var geometry = new THREE.BufferGeometry();
			var positions = [];
			var normals = [];
			var indices = [];
			var curIndex = 0;
			var stiffness = 0.999;
			var hairLength = 20.0;
			var gravity = new THREE.Vector3(0.0, -9.81, 0.0);
			
			//Build the initial geometry
			for(var j = 0; j < hairStrandCount; j++){			
				var p0 = new THREE.Vector3(Math.sin(j), 0, Math.cos(j)).multiplyScalar(5);
				var p1 = new THREE.Vector3(Math.sin(j), 0, Math.cos(j)).multiplyScalar(25);
				var p2 = new THREE.Vector3(Math.sin(j), -1, Math.cos(j)).multiplyScalar(25);
				
				//indices.push(j * detailLevel);
				
				for(var i = 0; i < detailLevel; i++){
					curIndex = j * detailLevel + i;
					indices.push(curIndex);
					
					var rootDir = new THREE.Vector3(Math.sin(j), 0, Math.cos(j));
				
					//var bezierVec = bezier(p0, p1, p2, i * detailDelta);
					var bezierVec = getStepSample(p0, rootDir, gravity, hairLength, stiffness, i * detailDelta);
					positions.push(bezierVec.x, bezierVec.y, bezierVec.z);
					//normals.push(rootDir.x, rootDir.y, rootDir.z);
					
					if(i < detailLevel - 2){
						indices.push(curIndex + 1);
					}
				}

				for(var i = 0; i < detailLevel; i++){
					var rootDir;
					
					var vertIndex = (j * detailLevel + i) * 3;
					
					if(i == detailLevel - 1){
						normals.push(normals[vertIndex - 3], normals[vertIndex - 2], normals[vertIndex - 1]);
					} else {
						rootDir = (new THREE.Vector3(
							positions[vertIndex + 3] - positions[vertIndex],
							positions[vertIndex + 4] - positions[vertIndex + 1],
							positions[vertIndex + 5] - positions[vertIndex + 2],
						)).normalize();
						normals.push(rootDir.x, rootDir.y, rootDir.z);
					}					
				}

				
				//var positions = line.geometry.attributes.position.array;

			}
			
			//console.log(indices);
			geometry.setIndex(indices);
			geometry.addAttribute('position', new THREE.Float32BufferAttribute( positions, 3));
			geometry.addAttribute('normal', new THREE.Float32BufferAttribute( normals, 3));			
			var line = new THREE.LineSegments( geometry, material );
			scene.add( line );


			var delta = 0.0;
			
			var panSpeed = 0.15;
			
			function updatePositions(){
				positions = line.geometry.attributes.position.array;
				
				var forceVector = new THREE.Vector3(0.0, Math.sin(time + Math.PI * 0.5) * 0.15, 0.0);
				
				for(var j = 0; j < hairStrandCount; j++){
					var tangentX = Math.cos(j) * Math.sin(time);
					var tangentZ = Math.sin(j) * Math.sin(time);
					for(var i = 0; i < detailLevel; i++){
						var vertIndex = (j * detailLevel + i) * 3;
						
						positions[vertIndex] += forceVector.x * i * detailDelta;
						positions[vertIndex + 1] += forceVector.y * i * detailDelta;
						positions[vertIndex + 2] += forceVector.z * detailDelta;
					}
				}
				
				//line.geometry.attributes.position.array = positions;
				line.geometry.attributes.position.needsUpdate = true;
			}
			
			function animate() {
				time = performance.now() * 0.001;
				//delta += 0.01;
			
				camera.position.set(Math.sin(time * panSpeed) * 100, 25, Math.cos(time * panSpeed) * 100);
				camera.lookAt(new THREE.Vector3(0, 0, 0));
			
				requestAnimationFrame( animate );
				
				updatePositions();
				
				renderer.render( scene, camera );
			}
			animate();
		</script>
	</body>
</html>	