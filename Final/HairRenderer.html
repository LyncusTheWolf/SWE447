<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Hair Shader</title>
		<style>
			body { 
				margin: 0;
				overflow: hidden;
			}
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<canvas id="myCanvas"></canvas>
		<script src="../Common/three.js"></script>
		
		<script type="x-shader/x-vertex" id="vertexShader">
			attribute float strandStepAttr;
		
			varying vec3 vecPos;
			varying vec3 vecNormal;
			varying vec3 lightDir;
			varying vec3 viewDir;
			varying float strandStep;
			
			vec3 lightPos = vec3(10.0, -3.0, 20.0);
			
			void main(){
				vecPos = (modelMatrix * vec4(position, 1.0)).xyz;
				vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;
				lightDir = normalize(lightPos - vecPos);
				viewDir = normalize(cameraPosition - vecPos);
				strandStep = strandStepAttr;
				gl_Position = projectionMatrix * viewMatrix * vec4(vecPos, 1.0);
			}
		</script>
		
		<script type="x-shader/x-fragment" id="fragmentShader">
			precision highp float;
			
			varying vec3 vecPos;
			varying vec3 vecNormal;
			varying vec3 lightDir;
			varying vec3 viewDir;
			varying float strandStep;
			
			/*uniform float lightIntensity;
		
			struct PointLight{
				vec3 color;
				vec3 position;
				float distance;
			};
			
			uniform PointLight pointLights[NUM_POINT_LIGHTS];*/
			
			float specularIntensity = 0.7;
			float rootShift = 0.2;
			float tipShift = 0.8;
			float ex1 = 0.95;
			float ex2 = 0.02;
			float spec1 = 0.5;
			float spec2 = 0.1;
		
			void main(){
				vec3 baseColor = vec3(0.5, 0.3, 0.1);
				vec3 tangent = vecNormal;
				
				//http://developer.amd.com/wordpress/media/2012/10/Scheuermann_HairRendering.pdf
				
				float cosTL = dot(tangent, lightDir);
				float sinTL = 1.0 - cosTL * cosTL;
				float diffuse = sinTL;
				
				float cosTRL = -cosTL;
				float sinTRL = sinTL;
				float cosTE = dot(tangent, viewDir);
				float sinTE = sqrt(1.0 - cosTE * cosTE);
				
				float cosTRL_root = cosTRL * cos(0.5 * strandStep) - sinTRL * sin(0.5 * strandStep);
				float sinTRL_root = sqrt(1.0 - cosTRL_root * cosTRL_root);
				float specular_root = max(0.0, cosTRL_root * cosTE + sinTRL_root * sinTE);
				
				float cosTRL_tip = cosTRL * cos(0.8 * strandStep) - sinTRL * sin(0.8 * strandStep);
				float sinTRL_tip = sqrt(1.0 - cosTRL_tip * cosTRL_tip);
				float specular_tip = max(0.0, cosTRL_tip * cosTE + sinTRL_tip * sinTE);
				
				vec3 finalColor = baseColor + (diffuse * baseColor + specularIntensity * (spec1 * pow(specular_root, ex1) + spec2 * pow(specular_tip, ex2)));
			
				gl_FragColor = vec4(finalColor, 1.0);// * addedLights;
			}
		</script>
		
		<script>
			/*float4 bezier(float4 p0, float4 p1, float4 p2, float t) {
				float oneMinusT = 1.0 - t;
				return
					oneMinusT * oneMinusT * p0 +
					2.0f * oneMinusT * t * p1 +
					t * t * p2;
			}*/
			
			function bezier(p0, p1, p2, t){
				var temp0 = p0.clone();
				var temp1 = p1.clone();
				var temp2 = p2.clone();
				var oneMinusT = 1.0 - t;
				
				temp0.multiplyScalar(oneMinusT * oneMinusT);
				temp1.multiplyScalar(2.0 * oneMinusT * t);
				temp2.multiplyScalar(t * t);
				//return (oneMinusT * oneMinusT * p0) + (2.0 * oneMinusT * t * p1) + (t * t * p2);
				return temp0.add(temp1).add(temp2);
			}
			
			function getStepSample(rootPos, rootNormal, gravity, length, stiffness, delta){
				//float4 subP0 = normalize(nA - (float4(0, v * t0, 0, 0) * _Gravity * t0)) * (v * t0);
				var deltaLength = length * delta;
				var deltaLengthVec = new THREE.Vector3(0, deltaLength, 0);
				var rootTemp = rootNormal.clone();
				var gravityTemp = gravity.clone();
				rootTemp.add(gravityTemp.multiply(deltaLengthVec).multiplyScalar(delta).multiplyScalar(1 - stiffness));
				return rootTemp.multiplyScalar(deltaLength).add(rootPos);
			}
			
			var detailLevel = 20;
		
			var time;

			var timeLastFrame = 0.0;
			var deltaTime = 0.0;
			var renderer;
			var scene;
			var camera;
			var myCanvas = document.getElementById('myCanvas');
			
			//RENDERER
			renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
			renderer.setClearColor(0xffffff);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			
			//CAMERA
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
			camera.position.set(0, 0, 100);
			camera.lookAt(new THREE.Vector3(0, 0, 0));
			
			//SCENE
			scene = new THREE.Scene();
			
			//LIGHTS
			var light = new THREE.AmbientLight(0xffffff, 0.5);
			scene.add(light);
			
			var light = new THREE.PointLight(0xffffff, 1.0);
			light.position.set(100.0, 25.0, 100.0);
			scene.add(light);
			
			//create a blue LineBasicMaterial
			//var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
			
			var material = new THREE.ShaderMaterial({
				uniforms: THREE.UniformsUtils.merge([
					THREE.UniformsLib['lights'],
					{
						lightIntensity: {type: 'f', value: 5.0}
						//textureSampler: {type: 't', value: null}
					}
				]),
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent,
				//transparent: true,
				lights: true
			});
			
			material.needsUpdate = true;
			
			var detailDelta = 1.0 / (detailLevel - 1);
			
			var hairStrandCount = 4000;
			var geometry = new THREE.BufferGeometry();
			var positions = [];
			var normals = [];
			//Two seperate index arrays, one for the stride buffer and one as an attribute buffer
			var strandSteps = [];
			var indices = [];
			var curIndex = 0;
			var stiffness = 0.999;
			var hairLength = 20.0;
			var gravity = new THREE.Vector3(0.0, -9.81, 0.0);
			
			var piStep = (Math.PI * 2.0 / hairStrandCount);
			
			//Build the initial geometry
			for(var j = 0; j < hairStrandCount; j++){			
				var p0 = new THREE.Vector3(Math.sin(j * piStep), 0, Math.cos(j)).multiplyScalar(15);
				p0.y = 10;
				//var p1 = new THREE.Vector3(Math.sin(j), 0, Math.cos(j)).multiplyScalar(25);
				//var p2 = new THREE.Vector3(Math.sin(j), -1, Math.cos(j)).multiplyScalar(25);
				
				//indices.push(j * detailLevel);
				
				//Construct the positions arrays
				for(var i = 0; i < detailLevel; i++){
					curIndex = j * detailLevel + i;
					
					//Push the vertex index into the index buffers
					indices.push(curIndex);
					strandSteps.push(i / (detailLevel - 1));
					
					var rootDir = new THREE.Vector3(Math.sin(j * piStep), 0, Math.cos(j * piStep));
				
					//var bezierVec = bezier(p0, p1, p2, i * detailDelta);
					var bezierVec = getStepSample(p0, rootDir, gravity, hairLength, stiffness, i * detailDelta);
					positions.push(bezierVec.x, bezierVec.y, bezierVec.z);
					//normals.push(rootDir.x, rootDir.y, rootDir.z);
					
					if(i < detailLevel - 2){
						indices.push(curIndex + 1);
					}
				}

				//Use the position arrays to construct a normals array
				for(var i = 0; i < detailLevel; i++){
					var rootDir;
					
					var vertIndex = (j * detailLevel + i) * 3;
					
					if(i == detailLevel - 1){
						normals.push(normals[vertIndex - 3], normals[vertIndex - 2], normals[vertIndex - 1]);
					} else {
						rootDir = (new THREE.Vector3(
							positions[vertIndex + 3] - positions[vertIndex],
							positions[vertIndex + 4] - positions[vertIndex + 1],
							positions[vertIndex + 5] - positions[vertIndex + 2],
						)).normalize();
						normals.push(rootDir.x, rootDir.y, rootDir.z);
					}					
				}

				
				//var positions = line.geometry.attributes.position.array;

			}
			
			//console.log(indices);
			geometry.setIndex(indices);
			geometry.addAttribute('position', new THREE.Float32BufferAttribute( positions, 3));
			geometry.addAttribute('normal', new THREE.Float32BufferAttribute( normals, 3));
			geometry.addAttribute('strandStepAttr', new THREE.Float32BufferAttribute(strandSteps, 1));				
			var line = new THREE.LineSegments( geometry, material );
			scene.add( line );


			var delta = 0.0;
			
			var panSpeed = 0.15;
			var damping = 0.15;
			
			function updatePositions(){
				positions = line.geometry.attributes.position.array;
				normals = line.geometry.attributes.normal.array;
				
				var windMag = (Math.sin(time * 3.0) + 1) * 0.5; 
				var gravity = new THREE.Vector3(0.0, -9.81, 0.0);
				var windForce = new THREE.Vector3(windMag * windMag * 5.0, 0.0, 0.0);
				var detailMinusOne = detailLevel - 1;
				

				
				for(var j = 0; j < hairStrandCount; j++){
					//console.log(j % 5);
					var dampingFactor = (j % 5) * damping;
					//console.log(dampingFactor);
				
					var rootIndex = j * detailLevel;
					
					var computationPosX = [];
					var computationPosY = [];
					var computationPosZ = [];
					
					//Initialize Local index values;
					for(var i = 0; i < detailLevel; i++){
						var vertIndex = (j * detailLevel + i) * 3;
						
						computationPosX.push(positions[vertIndex]);
						computationPosY.push(positions[vertIndex + 1]);
						computationPosZ.push(positions[vertIndex + 2]);
					}
					
					//Apply forces in positions
					for(var i = 1; i < detailLevel; i++){
						var windFactor = (j % 5) * windForce;
						var tempX = computationPosX[i] + (windForce.x + gravity.x) * deltaTime;
						tempX += dampingFactor * (computationPosX[i] - tempX);
						computationPosX[i] = tempX;
						
						var tempY = computationPosY[i] + gravity.y * deltaTime;
						tempY += dampingFactor * (computationPosY[i] - tempY);
						computationPosY[i] = tempY;
						
						var tempZ = computationPosZ[i] + gravity.z * deltaTime;
						tempZ += dampingFactor * (computationPosZ[i] - tempZ);
						computationPosZ[i] = tempZ;
					}
					
					//Apply length constraints
					for(var i = 1; i < detailLevel; i++){
						var dirX;
						var dirY;
						var dirZ;
						
						dirX = computationPosX[i] - computationPosX[i - 1];
						dirY = computationPosY[i] - computationPosY[i - 1];
						dirZ = computationPosZ[i] - computationPosZ[i - 1];
					
						var hLength = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
						var offset = Math.min(hLength, 1.0) / hLength;
						
						computationPosX[i] = computationPosX[i - 1] + dirX * offset;
						computationPosY[i] = computationPosY[i - 1] + dirY * offset;
						computationPosZ[i] = computationPosZ[i - 1] + dirZ * offset;
					}
					
					//Bake in positions
					for(var i = 0; i < detailLevel; i++){
						var vertIndex = (j * detailLevel + i) * 3;
						
						positions[vertIndex] = computationPosX[i];
						positions[vertIndex + 1] = computationPosY[i];
						positions[vertIndex + 2] = computationPosZ[i];
					}
					
					//Bake in normals
					for(var i = 0; i < detailLevel; i++){
						var vertIndex = (j * detailLevel + i) * 3;
						
						//If at the tip, get the normal of the previous vert
						if(i == detailMinusOne){
							normals[vertIndex] = normals[vertIndex - 3];
							normals[vertIndex + 1] = normals[vertIndex - 2];
							normals[vertIndex + 2] = normals[vertIndex - 1];
						} else {
							var normDir = (new THREE.Vector3(
								computationPosX[i + 1] - computationPosX[i],
								computationPosY[i + 1] - computationPosY[i],
								computationPosZ[i + 1] - computationPosZ[i],
							)).normalize();
							
							normals[vertIndex] = normDir.x;
							normals[vertIndex + 1] = normDir.y;
							normals[vertIndex + 2] = normDir.z;
						}
					}
				}
				
				//line.geometry.attributes.position.array = positions;
				line.geometry.attributes.position.needsUpdate = true;
				line.geometry.attributes.normal.needsUpdate = true;
			}
			
			
			
			function animate() {
				time = performance.now() * 0.001;
				deltaTime = time - timeLastFrame;
				timeLastFrame = time;
				//delta += 0.01;
			
				camera.position.set(Math.sin(time * 0.15) * 15, 25, 50);
				camera.lookAt(new THREE.Vector3(0, -5, 0));
			
				//camera.position.set(Math.sin(time * panSpeed) * 100, 25, Math.cos(time * panSpeed) * 100);
				//camera.lookAt(new THREE.Vector3(0, 0, 0));
			
				requestAnimationFrame( animate );
				
				updatePositions(deltaTime);
				
				renderer.render( scene, camera );
			}
			animate();
		</script>
	</body>
</html>	